const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)
const { resource } = require('helpers')

module.exports = quick_editor
let is_called

async function quick_editor(opts) {
  // ----------------------------------------
  let init
  let data
  let port
  const current_data = {}

  const { sdb, io, net } = await get(opts.sid)
  const { drive } = sdb

  const on = {
    style: inject
  }
  // ----------------------------------------
  const el = document.createElement('div')
  el.classList.add('quick-editor')
  const shadow = el.attachShadow({ mode: 'closed' })

  shadow.innerHTML = `
      <button class="dots-button">â‹®</button>
      <div class="quick-box">
        <div class="quick-menu hidden">
          <!-- Root Tabs -->
          <div class="root-btns">
          </div>
          <div class="root-tabs">
          </div>
          <div class="btn-box">
            <button class="button">Apply</button>
            ${is_called ? '' :
              `<button class="button import">Import</button>
              <button class="button export">Export</button>
              <input type="file" accept='.json' hidden />`
            }
          </div>
        </div>
      </div>
      <style>
      </style>
      `


  const style = shadow.querySelector('style')
  const menu_btn = shadow.querySelector('.dots-button')
  const menu = shadow.querySelector('.quick-menu')
  const import_btn = shadow.querySelector('.button.import')
  const export_btn = shadow.querySelector('.button.export')
  const input = shadow.querySelector('input')
  const apply_btn = shadow.querySelector('.button')
  const root_btns = shadow.querySelector('.root-btns')
  const root_tabs = shadow.querySelector('.root-tabs')
  // ----------------------------------------
  // EVENTS
  // ----------------------------------------
  await sdb.watch(onbatch)
  menu_btn.onclick = () => menu_click(false)
  if (is_called) {
    apply_btn.onclick = apply
    menu_btn.onclick = () => menu_click(true)
  }
  else {
    apply_btn.onclick = () => {
      port.postMessage({ type: 'swtch', data: [{ name: current_data.dataset, type: current_data.node }] })
    }
    input.onchange = upload
    import_btn.onclick = () => {
      input.click()
    }
    export_btn.onclick = () => {
      port.postMessage({ type: 'export_db', data: [{ name: current_data.dataset, type: current_data.node }] })
    }
  }

  // ----------------------------------------
  // IO
  // ----------------------------------------
  const item = resource()
  io.on(port => {
    const { by, to } = port
    item.set(port.to, port)
    port.onmessage = event => {
      const txt = event.data
      const key = `[${by} -> ${to}]`
      data = txt
      if (init) {
        menu_click(false)
        init = false
        menu_click(false)
      }
    }
  })
  await io.at(net.page.id)
  is_called = true
  return el

  // ----------------------------------------
  // FUNCTIONS
  // ----------------------------------------
  function upload(e) {
    const file = e.target.files[0]
    const reader = new FileReader()
    reader.onload = event => {
      const content = event.target.result
      try {
        data = JSON.parse(content)
        port.postMessage({ type: 'import_db', data: [data] })
      } catch (err) {
        console.error('Invalid JSON file', err)
      }
    }
    reader.readAsText(file)
  }
  function make_btn(name, classes, tab_id, key) {
    const btn = document.createElement('button')
    btn.textContent = name
    btn.classList.add(...classes.split(' '))
    btn.setAttribute('tab', name)
    btn.setAttribute('tab_id', tab_id)
    btn.setAttribute('key', key)
    btn.setAttribute('title', name)
    return btn
  }
  function make_tab(id, classes, sub_classes) {
    const tab = document.createElement('div')
    tab.classList.add(...classes.split(' '))
    tab.id = id.replaceAll(/[^A-Za-z0-9]/g, '')
    tab.innerHTML = `
      <div class="${sub_classes[0]}">
      </div>
      <div class="${sub_classes[1]}">
      </div>
    `
    return tab
  }
  function make_textarea(id, classes, value) {
    const textarea = document.createElement('textarea')
    textarea.id = id.replaceAll(/[^A-Za-z0-9]/g, '')
    textarea.classList.add(...classes.split(' '))
    textarea.value = typeof (value) === 'object' ? JSON.stringify(value, null, 2) : value
    textarea.placeholder = 'Type here...'
    return textarea
  }
  async function menu_click(call) {
    port = await item.get(net.page.id)
    menu.classList.toggle('hidden')
    if (init)
      return
    init = true
    root_btns.innerHTML = ''
    root_tabs.innerHTML = ''
    Object.entries(data).forEach(([node, datasets], k) => {
      let first = ''
      if (!k) {
        first = ' active'
        current_data.node = node
      }
      const no_slash = node.split('/').at(-1)
      const btn = make_btn(no_slash, `tab-button${first}`, node, 'node')
      const tab = make_tab(no_slash, `tab-content${first}`, ['top-btns', 'top-tabs'])

      btn.onclick = () => tab_btn_click(btn, root_btns, root_tabs, '.root-tabs > .tab-content', 'node', node)

      root_btns.append(btn)
      root_tabs.append(tab)

      const top_btns = tab.querySelector('.top-btns')
      const top_tabs = tab.querySelector('.top-tabs')
      Object.entries(datasets).forEach(([dataset, files], i) => {
        let first = ''
        if (!i) {
          first = ' active'
          if (!k)
            current_data.dataset = dataset
        }
        const no_slash = dataset.split('/')[0]
        const btn = make_btn(no_slash, `tab-button${first}`, dataset, 'dataset')
        const tab = make_tab(no_slash, `tab-content${first}`, ['sub-btns', 'subtab-content'])

        btn.onclick = () => tab_btn_click(btn, top_btns, top_tabs, '.tab-content', 'dataset', dataset)

        top_btns.append(btn)
        top_tabs.append(tab)

        const sub_btns = tab.querySelector('.sub-btns')
        const subtab = tab.querySelector('.subtab-content')
        Object.entries(files).forEach(([file, raw], j) => {
          let first = ''
          if (!j) {
            first = ' active'
            if (!i && !k)
              current_data.file = file
          }
          const sub_btn = make_btn(file, `sub-btn${first}`, file, 'file')
          const textarea = make_textarea(file, `subtab-textarea${first}`, raw)

          sub_btn.onclick = () => tab_btn_click(sub_btn, sub_btns, subtab, '.subtab-textarea', 'file', file)

          sub_btns.append(sub_btn)
          subtab.append(textarea)
        })
      })
    })

  }
  function tab_btn_click(btn, btns, tabs, tab_class, key, name) {
    btns.querySelector('.active').classList.remove('active')
    tabs.querySelector(tab_class + '.active').classList.remove('active')

    btn.classList.add('active')
    const tab = tabs.querySelector('#' + btn.getAttribute('tab').replaceAll(/[^A-Za-z0-9]/g, ''))
    tab.classList.add('active')
    current_data[btn.getAttribute('key')] = btn.getAttribute('tab_id')
    const active_btns = tab.querySelectorAll('button.active')
    active_btns.forEach(active_btn => {
      current_data[active_btn.getAttribute('key')] = active_btn.getAttribute('tab_id')
    })
  }

  function apply() {
    let raw = shadow.querySelector('.tab-content.active .tab-content.active textarea.active').value
    if (current_data.file.split('.')[1] === 'json')
      raw = JSON.parse(raw)
    port.postMessage({
      type: 'put', data: [
        current_data.dataset + current_data.file,
        raw,
        current_data.node
      ]
    })
  }

  function inject(data) {
    style.textContent = data.join('\n')
  }
  async function onbatch(batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }

  function fail(data, type) { throw new Error('invalid message', { cause: { data, type } }) }

}


function fallback_module() {
  return {
    api: fallback_instance
  }
  function fallback_instance() {
    return {
      drive: {
        'style/': {
          'quick_editor.css': {
            raw: `
            .dots-button {
              border: none;
              font-size: 24px;
              cursor: pointer;
              line-height: 1;
              background-color: white;
              letter-spacing: 1px;
              padding: 3px 5px;
              border-radius: 20%;
              box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }

            .quick-menu {
              display: flex;
              position: absolute;
              top: 100%;
              right: 0;
              background: white;
              padding: 8px;
              box-shadow: 0 2px 8px rgba(0,0,0,0.15);
              white-space: nowrap;
              z-index: 10;
              width: fit-content;
            }

            .hidden {
              display: none;
            }
            .root-btns{
              display: flex;
              flex-direction: column;
              gap: 4px;
              margin-right: 10px;
            }

            .top-btns {
              display: flex;
              margin-bottom: 8px;
            }

            .tab-button {
              flex: 1;
              padding: 6px 10px;
              background: #eee;
              border: none;
              cursor: pointer;
              border-bottom: 2px solid transparent;
            }
            .tab-button.active {
              background: white;
              border-bottom: 2px solid #4CAF50;
            }
            .tab-content {
              display: none;
            }
            .tab-content.active {
              display: block;
            }

            .sub-btns {
              float: right;
              display: flex;
              flex-direction: column;
              gap: 4px;
              margin-left: 5px;
              max-height: 400px;
              overflow-y: auto;
            }

            .sub-btn {
              padding: 4px 8px;
              background: #f1f1f1;
              border: none;
              cursor: pointer;
              text-align: right;
              max-width: 100px;
              text-overflow: ellipsis;
              overflow: hidden;
              min-height: 30px;
            }
            .sub-btn.active {
              background: #d0f0d0;
            }

            .subtab-content {
              overflow: hidden;
            }

            .subtab-textarea {
              width: 300px;
              height: 400px;
              display: none;
              resize: vertical;
              margin-right: 100px;
            }
            .subtab-textarea.active {
              display: block;
            }

            .button {
              display: block;
              margin-top: 10px;
              padding: 5px 10px;
              background-color: #4CAF50;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              height: fit-content;
              self-align: end;
              width: 100%;
            }
            .btn-box {
              border-left: 1px solid #ccc;
              padding-left: 10px;
            }
            `
          }
        }
      }
    }
  }
}