const STATE = require('STATE')
const statedb = STATE(__filename)
const { get } = statedb(fallback_module)
const { resource } = require('helpers')

module.exports = quick_editor
let is_called
const nesting = 0

async function quick_editor(opts) {
  // ----------------------------------------
  let init, data, port, labels, nesting_limit, top_first, select = []
  const current_data = {}

  const { sdb, io, net } = await get(opts.sid)
  const { drive } = sdb

  const on = {
    style: inject
  }
  // ----------------------------------------
  const el = document.createElement('div')
  el.classList.add('quick-editor')
  const shadow = el.attachShadow({ mode: 'closed' })

  shadow.innerHTML = `
      <button class="dots-button">â‹®</button>
      <div class="quick-box">
        <div class="quick-menu hidden">
          <div class="btn-box">
            <button class="button">Apply</button>
            ${is_called ? '' :
              `<button class="button import">Import</button>
              <button class="button export">Export</button>
              <input type="file" accept='.json' hidden />`
            }
          </div>
        </div>
      </div>
      <style>
      </style>
      `


  const style = shadow.querySelector('style')
  const menu_btn = shadow.querySelector('.dots-button')
  const menu = shadow.querySelector('.quick-menu')
  const import_btn = shadow.querySelector('.button.import')
  const export_btn = shadow.querySelector('.button.export')
  const input = shadow.querySelector('input')
  const apply_btn = shadow.querySelector('.button')
  // ----------------------------------------
  // EVENTS
  // ----------------------------------------
  await sdb.watch(onbatch)
  menu_btn.onclick = () => menu_click(false)
  if (is_called) {
    apply_btn.onclick = apply
    menu_btn.onclick = () => menu_click(true)
    labels = ['Nodes', 'Types', 'Files']
    nesting_limit = nesting + 3
    top_first = 0
  }
  else {
    apply_btn.onclick = () => {
      port.postMessage({ type: 'swtch', data: [{ name: current_data.Types.trim(), type: current_data.Names.trim() }] })
    }
    input.onchange = upload
    import_btn.onclick = () => {
      input.click()
    }
    export_btn.onclick = () => {
      if(current_data.radio.name === 'Names')
        port.postMessage({ type: 'export_db', data: [{ name: current_data.Names.trim(), type: current_data.Types.trim() }]})
      else
        port.postMessage({ type: 'export_root', data: [{ name: current_data.Root.trim(), type: current_data.Nodes.trim() }]})
    }
    menu.classList.add('admin')
    labels = ['Root', 'Types', 'Names', 'Nodes', 'Files', 'Entries']
    nesting_limit = nesting + 6
    top_first = 1
    select = [1, 0, 1, 0, 0, 0]
  }

  // ----------------------------------------
  // IO
  // ----------------------------------------
  const item = resource()
  io.on(port => {
    const { by, to } = port
    item.set(port.to, port)
    port.onmessage = event => {
      const txt = event.data
      const key = `[${by} -> ${to}]`
      data = txt
      if (init) {
        menu_click(false)
        init = false
        menu_click(false)
      }
    }
  })
  await io.at(net.page.id)
  is_called = true
  return el

  // ----------------------------------------
  // FUNCTIONS
  // ----------------------------------------
  function upload(e) {
    const file = e.target.files[0]
    const reader = new FileReader()
    reader.onload = event => {
      const content = event.target.result
      try {
        data = JSON.parse(content)
        console.log(file)
        if(current_data.radio.name === 'Names')
          port.postMessage({ type: 'import_db', data: [data] })
        else
          port.postMessage({ type: 'import_root', data: [data, file.name.split('.')[0]] })

      } catch (err) {
        console.error('Invalid JSON file', err)
      }
    }
    reader.readAsText(file)
  }
  function make_btn(name, classes, key, nesting) {
    const btn = document.createElement('button')
    if(select[nesting]){
        btn.innerHTML = `
        <input type='radio' name='${key}' /> ${name}
      `
      const input = btn.querySelector('input')
      input.onchange = () => radio_change(input)
    }
    else
      btn.textContent = name
    btn.classList.add(...classes.split(' '))
    btn.setAttribute('tab', name.replaceAll(/[^A-Za-z0-9]/g, ''))
    btn.setAttribute('key', key)
    btn.setAttribute('title', name)
    return btn
  }
  function make_tab(id, classes, sub_classes, nesting = 0) {
    const tab = document.createElement('div')
    tab.classList.add(...classes.split(' '), id.replaceAll(/[^A-Za-z0-9]/g, ''))

    if (nesting % 2 === top_first)
      var height = 565 - ((nesting + 1) * 30) + 'px'
    else
      tab.style.maxWidth = 700 - ((nesting + 1) * 47) + 'px'

    tab.innerHTML = `
      <div class="${sub_classes[0]}" style="--before-content: '${labels[nesting]}'; max-height: ${height}">
      </div>
      <div class="${sub_classes[1]}">
      </div>
    `

    return tab
  }
  function make_textarea(id, classes, value, nesting) {
    const textarea = document.createElement('textarea')
    textarea.id = id.replaceAll(/[^A-Za-z0-9]/g, '')
    textarea.classList.add(...classes.split(' '))
    textarea.value = typeof (value) === 'object' ? JSON.stringify(value, null, 2) : value
    textarea.placeholder = 'Type here...'
    textarea.style.width = 700 - ((nesting + 2) * 47) + 'px'
    return textarea
  }
  function radio_change (radio) {
    current_data.radio && (current_data.radio.checked = false)
    current_data.radio = radio
  }
  async function menu_click(call) {
    port = await item.get(net.page.id)
    menu.classList.toggle('hidden')
    if (init)
      return
    init = true

    const old_box = menu.querySelector('.tab-content')
    old_box && old_box.remove()

    const box = make_tab('any', 'tab-content active' + (top_first ? '' : ' sub'), ['btns', 'tabs'])
    menu.append(box)
    make_tabs(box, data, nesting)
  }
  function make_tabs(box, data, nesting) {
    const local_nesting = nesting + 1
    const not_last_nest = local_nesting !== nesting_limit
    let sub = ''
    if (local_nesting % 2 === top_first)
      sub = ' sub'
    const btns = box.querySelector(`.btns`)
    const tabs = box.querySelector(`.tabs`)
    Object.entries(data).forEach(([key, value], i) => {
      let first = ''
      if (!i) {
        first = ' active'
        current_data[labels[nesting]] = key
      }
      
      const btn = make_btn(key, `tab-button${first}`, labels[nesting], nesting)
      const tab = make_tab(key, `tab-content${sub+first}`, ['btns', 'tabs'], local_nesting)
      btn.onclick = () => tab_btn_click(btn, btns, tabs, '.root-tabs > .tab-content', 'node', key)

      btns.append(btn)
      tabs.append(tab)
      if(typeof(value) === 'object' && value !== null && not_last_nest && Object.keys(value).length)
        make_tabs(tab, value, local_nesting)
      else {
        const textarea = make_textarea(key, `subtab-textarea${first}`, value, local_nesting)
        tab.append(textarea)
      }
    })
  }
  function tab_btn_click(btn, btns, tabs) {
    btns.querySelector('.active').classList.remove('active')
    tabs.querySelector(':scope > .active').classList.remove('active')

    btn.classList.add('active')
    const tab = tabs.querySelector('.' + btn.getAttribute('tab'))
    tab.classList.add('active')
    current_data[btn.getAttribute('key')] = btn.textContent

    recurse(tab)
    function recurse (tab) {
      const btn = tab.querySelector('.btns > .active')
      if(!btn)
        return
      current_data[btn.getAttribute('key')] = btn.textContent
      const sub_tab = tab.querySelector('.tabs > .active')
      recurse(sub_tab)
    }
  }

  function apply() {
    let raw = shadow.querySelector('.tab-content.active .tab-content.active textarea.active').value
    if (current_data.file.split('.')[1] === 'json')
      raw = JSON.parse(raw)
    port.postMessage({
      type: 'put', data: [
        current_data.dataset + current_data.file,
        raw,
        current_data.node
      ]
    })
  }

  function inject(data) {
    style.textContent = data.join('\n')
  }
  async function onbatch(batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }

  function fail(data, type) { throw new Error('invalid message', { cause: { data, type } }) }

}


function fallback_module() {
  return {
    api: fallback_instance
  }
  function fallback_instance() {
    return {
      drive: {
        'style/': {
          'quick_editor.css': {
            raw: `
            .dots-button {
              border: none;
              font-size: 24px;
              cursor: pointer;
              line-height: 1;
              background-color: white;
              letter-spacing: 1px;
              padding: 3px 5px;
              border-radius: 20%;
              box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }

            .quick-menu {
              display: flex;
              position: absolute;
              top: 100%;
              right: 0;
              background: white;
              padding: 8px;
              box-shadow: 0 2px 8px rgba(0,0,0,0.15);
              white-space: nowrap;
              z-index: 10;
              width: fit-content;
            }
            *{
              box-sizing: border-box;
            }

            .hidden {
              display: none;
            }
            
            .btns::before {
              display: none;
              content: var(--before-content);
              font-weight: bold;
              color: white;
              background: #4CAF50;
              padding: 2px 6px;
              border-radius: 4px;
              position: absolute;
              margin-left: -10px;
              margin-top: -20px;
            }
            .btns:hover {
              border: 2px solid #4CAF50;
            }
            .btns:hover::before {
              display: block;
            }
            .btns{
              display: flex;
              margin-bottom: 8px;
              overflow-x: auto;
              background: #d0f0d0;
            }
            .sub > .btns {
              display: flex;
              flex-direction: column;
              gap: 4px;
              max-height: 400px;
              overflow-y: auto;
              min-width: fit-content;
              margin-right: 8px;
              background: #d0d2f0ff;
            }

            .tab-button {
              flex: 1;
              padding: 6px;
              background: #eee;
              border: none;
              cursor: pointer;
              border-bottom: 2px solid transparent;
              max-width: 70px;
              width: fit-content;
              text-overflow: ellipsis;
              overflow: hidden;
              min-width: 70px;
              min-height: 29px;
              position: relative;
              text-align: left;
            }
            .tab-button.active {
              background: #fff;
              border-bottom: 2px solid #4CAF50;
            }
            .sub > div > .tab-button.active {
              border-bottom: 2px solid #2196F3;
            }
            .tab-content {
              display: none;
              max-width: 700px;
              background: #d0d2f0ff;
            }
            .tab-content.active {
              display: block;
            }
            .tab-content.sub.active{
              display: flex;
              align-items: flex-start;
            }

            textarea {
              width: 500px;
              max-width: 560px;
              height: 400px;
              display: block;
              resize: vertical;
            }

            .button {
              display: block;
              margin-top: 10px;
              padding: 5px 10px;
              background-color: #4CAF50;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              height: fit-content;
              self-align: end;
              width: 100%;
            }
            .btn-box {
              border-right: 1px solid #ccc;
              padding-right: 10px;
            }
            .tabs{
              border-left: 2px solid #ccc;
              border-top: 1px solid #ccc;
            }
            button:has(input[type="radio"]:checked){
              background: #45abffff;
            }
            button > input[type="radio"]{
              width: 12px;
              height: 12px;
              border: 2px solid #555;
              border-radius: 50%;
              display: inline-block;
              position: relative;
              cursor: pointer;
              margin: 0;
            }
            `
          }
        }
      }
    }
  }
}