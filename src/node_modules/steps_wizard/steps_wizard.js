const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

module.exports = steps_wizard

async function steps_wizard (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const {drive} = sdb
  
  const on = {
    style: inject
  }

  let variables = []

  let _ = null
  if(protocol){
    send = protocol(msg => onmessage(msg))
    _ = { up: send }
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="steps-wizard main">
    <div class="steps-container">
      <div class="steps-slot"></div>
      <button class="nav-arrow left" id="leftArrow">‹</button>
      <button class="nav-arrow right" id="rightArrow">›</button>
    </div>
  </div>
  <style>
  </style>
  `

  const style = shadow.querySelector('style')
  const steps_container = shadow.querySelector('.steps-container')
  const steps_entries = shadow.querySelector('.steps-slot')
  const leftArrow = shadow.querySelector('#leftArrow')
  const rightArrow = shadow.querySelector('#rightArrow')
  
  const subs = await sdb.watch(onbatch)

  setupArrowNavigation()

  // for demo purpose
  render_steps([
    {name: "Optional Step", "type": "optional", "is_completed": false, "component": "form_input", "status": "default", "data": ""},
	  {name: "Step 2", "type": "mandatory", "is_completed": false, "component": "form_input", "status": "default", "data": ""},
    {name: "Step 3", "type": "mandatory", "is_completed": false, "component": "form_input", "status": "default", "data": ""},
    {name: "Step 4", "type": "mandatory", "is_completed": false, "component": "form_input", "status": "default", "data": ""},
    {name: "Step 5", "type": "mandatory", "is_completed": false, "component": "form_input", "status": "default", "data": ""},
    {name: "Step 6", "type": "mandatory", "is_completed": false, "component": "form_input", "status": "default", "data": ""},
    {name: "Step 7", "type": "mandatory", "is_completed": false, "component": "form_input", "status": "default", "data": ""},
    {name: "Step 8", "type": "mandatory", "is_completed": false, "component": "form_input", "status": "default", "data": ""},
    {name: "Step 9", "type": "mandatory", "is_completed": false, "component": "form_input", "status": "default", "data": ""},
    {name: "Step 10", "type": "mandatory", "is_completed": false, "component": "form_input", "status": "default", "data": ""},
    {name: "Step 11", "type": "mandatory", "is_completed": false, "component": "form_input", "status": "default", "data": ""},
    {name: "Step 12", "type": "mandatory", "is_completed": false, "component": "form_input", "status": "default", "data": ""},
  ])

  return el

  function setupArrowNavigation() {
    function updateArrows() {
      const scrollLeft = steps_entries.scrollLeft
      const maxScroll = steps_entries.scrollWidth - steps_entries.clientWidth
      
      if (scrollLeft > 0) {
        leftArrow.classList.add('visible')
        steps_container.classList.add('has-left-overflow')
      } else {
        leftArrow.classList.remove('visible')
        steps_container.classList.remove('has-left-overflow')
      }
      
      if (scrollLeft < maxScroll - 1) {
        rightArrow.classList.add('visible')
        steps_container.classList.add('has-right-overflow')
      } else {
        rightArrow.classList.remove('visible')
        steps_container.classList.remove('has-right-overflow')
      }
    }

    leftArrow.addEventListener('click', () => {
      const stepWidth = steps_entries.children[0]?.offsetWidth || 200
      steps_entries.scrollBy({
        left: -(stepWidth + 8),
        behavior: 'smooth'
      })
    })

    rightArrow.addEventListener('click', () => {
      const stepWidth = steps_entries.children[0]?.offsetWidth || 200
      steps_entries.scrollBy({
        left: stepWidth + 8,
        behavior: 'smooth'
      })
    })

    steps_entries.addEventListener('scroll', updateArrows)
    
    window.addEventListener('resize', () => {
      setTimeout(updateArrows, 100)
    })

    setTimeout(updateArrows, 100)
  }
  
  function onmessage ({ type, data }) {
    console.log('steps_ data', type, data)
    if (type === 'init_data') {
      variables = data
      render_steps(variables)
    }
  }
  
  function render_steps(steps) {
    if (!steps)
      return;

    steps_entries.innerHTML = '';

    steps.forEach((step, index) => {
      const btn = document.createElement('button')
      btn.className = 'step-button'
      btn.textContent = step.name + (step.type === 'optional' ? ' *' : '')
      btn.setAttribute('data-step', index + 1)

      const accessible = can_access(index, steps)

      let status = 'default'
      if (!accessible) status = 'disabled'
      else if (step.is_completed) status = 'completed'
      else if (step.status === 'error') status = 'error'
      else if (step.type === 'optional') status = 'optional'

      btn.classList.add(`step-${status}`)

      btn.onclick = async () => {
        console.log('Clicked:', step)
        _?.up({type: 'step_clicked', data: {...step, index, total_steps: steps.length, is_accessible: accessible}})
      };

      steps_entries.appendChild(btn)
    });
    
    setTimeout(() => {
      const scrollLeft = steps_entries.scrollLeft
      const maxScroll = steps_entries.scrollWidth - steps_entries.clientWidth
      
      if (scrollLeft > 0) {
        leftArrow.classList.add('visible')
        steps_container.classList.add('has-left-overflow')
      }
      
      if (scrollLeft < maxScroll - 1) {
        rightArrow.classList.add('visible')
        steps_container.classList.add('has-right-overflow')
      }
    }, 100)
  }

  function can_access(index, steps) {
    for (let i = 0; i < index; i++) {
      if (!steps[i].is_completed && steps[i].type !== 'optional') {
        return false
      }
    }

    return true
  }

  async function onbatch(batch) {
    for (const { type, paths } of batch){
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
  }
  function fail(data, type) { throw new Error('invalid message', { cause: { data, type } }) }
  function inject (data) {
    style.replaceChildren((() => {
      return document.createElement('style').textContent = data[0]
    })())
  }
 
}

function fallback_module () {
  return {
    api: fallback_instance
  }

  function fallback_instance () {
    return {
      drive: {
        'style/': {
          'stepswizard.css': {
            '$ref': 'stepswizard.css' 
          }
        }
      }
    }
  }
}