const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

module.exports = component

async function component (opts, protocol) {
  const { sdb } = await get(opts.sid)
  const { drive } = sdb
  const on = {
    style: inject_style,
    entries: on_entries,
    icons: iconject
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="graph-explorer">
    <div class="explorer-container"></div>
  </div>`

  const container = shadow.querySelector('.explorer-container')

  /******************************************************************************
  Variables for entries and view management. To get data from the state drive.
  ******************************************************************************/
  let entries = []
  let view = []
  let view_num = 0
  let expanded_nodes = new Set()
  let init = false

  /******************************************************************************
  Intersection Observer to track which nodes are currently in view.
  //TODO: Lazy loading of nodes based on scroll visibility.
  ******************************************************************************/
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      const node_id = entry.target.dataset.path
      if (entry.isIntersecting) {
        if (!view.includes(node_id)) {
          view.push(node_id)
        }
      } else {
        const index = view.indexOf(node_id)
        if (index !== -1) {
          view.splice(index, 1)
        }
      }
    })
  }, {
    root: container,
    threshold: 0.1
  })

  function calculate_view_num() {
    const container_height = container.clientHeight
    const node_height = 24
    view_num = Math.ceil(container_height / node_height) * 3 || 30
    // console.log('view:', view)
  }


  const subs = await sdb.watch(onbatch)

  /******************************************************************************
  Resize Observer
  ******************************************************************************/
  const resize_observer = new ResizeObserver(() => {
    calculate_view_num()
    render_visible_nodes()
  })
  resize_observer.observe(container)

  let send = null
  if (protocol) {
    send = protocol(msg => onmessage(msg))
  }

  return el

  function onmessage(msg) {
    // console.log('Graph Explorer received message:', msg)
  }

  async function onbatch(batch) {
    for (const { type, paths } of batch) {
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
    if (!init && entries.length > 0) {
      calculate_view_num()
      render_visible_nodes()
      init = true
    }
  }

  function fail (data, type) { 
    throw new Error('invalid message', { cause: { data, type } }) 
  }

  function on_entries(data) {
    entries = typeof data[0] === 'string' ? JSON.parse(data[0]) : data[0]
  }
  function iconject(data) {
    icons = data
  }
  function inject_style(data) {
    const sheet = new CSSStyleSheet()
    sheet.replaceSync(data)
    shadow.adoptedStyleSheets = [sheet]
  }
  /******************************************************************************
  Function for the rendering based on the visible nodes.
  ******************************************************************************/
  function render_visible_nodes() {
    container.replaceChildren()
    if (entries.length === 0) return
    
    const visible_entries = calculate_visible_entries()
    visible_entries.forEach(entry => {
      const node = create_node(entry)
      // console.log(container, node)
      container.appendChild(node)
      observer.observe(node)
    })
  }

  function calculate_visible_entries() {
    const visible_entries = []
    visible_entries.push(entries[0])
    let queue = [...entries[0].subs.map(index => entries[index])]
    
    while (queue.length > 0 && visible_entries.length < view_num) {
      const entry = queue.shift()
      if (!entry) continue
      visible_entries.push(entry)

      const entry_path = get_full_path(entry)
      if (expanded_nodes.has(entry_path) && entry.subs && entry.subs.length > 0) {
        queue = [...entry.subs.map(index => entries[index]), ...queue]
      }
    }
    
    return visible_entries
  }
  /******************************************************************************
  Create a node element for the explorer tree.
  ******************************************************************************/
  function create_node(entry) {
    const node = document.createElement('div')
    const depth = calculate_depth(entry.path)
    const is_expanded = expanded_nodes.has(get_full_path(entry))
    const has_children = entry.subs && entry.subs.length > 0
    
    let icon = get_icon_for_type(entry.type)
    let prefix = create_tree_prefix(entry, depth, is_expanded, has_children)
    
    node.className = 'explorer-node'
    node.dataset.path = get_full_path(entry)
    node.dataset.index = entries.indexOf(entry)
    node.style.paddingLeft = `${depth * 10}px`
    
    node.innerHTML = `
      <span class="tree-prefix">${prefix}</span>
      <span class="node-icon">${icon}</span>
      <span class="node-name">${entry.name}</span>
    `
    
    // Setup click handlers
    const prefix_el = node.querySelector('.tree-prefix')
    const icon_el = node.querySelector('.node-icon')
    
    if (has_children) {
      prefix_el.onclick = null
      //TODO: Add supernode support
      icon_el.onclick = () => toggle_node(entry)
    }
    
    return node
  }

  // Toggle node expansion state
  function toggle_node(entry) {
    const path = get_full_path(entry)
    
    if (expanded_nodes.has(path)) {
      expanded_nodes.delete(path)
    } else {
      expanded_nodes.add(path)
    }
    render_visible_nodes()
    // console.log('view:', view)
    // console.log('view:', view_num)
  }

  // Get appropriate icon for entry type
  function get_icon_for_type(type) {
    const type_icons = {
      'root': 'ğŸŒ',
      'folder': 'ğŸ“',
      'file': 'ğŸ“„',
      'html-file': 'ğŸ“„',
      'js-file': 'ğŸ“„',
      'css-file': 'ğŸ–Œï¸',
      'json-file': 'ğŸ¨'
    }
    
    return type_icons[type] || 'ğŸ“„'
  }
  /******************************************************************************
   Prefix creation for tree structure.
   //TODO: Add support for different icons based on entry type.
  /******************************************************************************/
  function create_tree_prefix(entry, depth, is_expanded, has_children) {
    if (depth === 0) return has_children ? (is_expanded ? 'ğŸª„â”¬' : 'ğŸª„â”¬') : 'ğŸª„â”€'
    if (has_children) {
      return is_expanded ? 'â”œâ”¬' : 'â”œâ”€'
    } else {
      return 'â””â”€'
    }
  }

  function calculate_depth(path) {
    if (!path) return 0
    return (path.match(/\//g) || []).length
  }
  function get_full_path(entry) {
    return entry.path + entry.name + '/'
  }
}

function fallback_module() {
  return {
    api: fallback_instance
  }
  
  function fallback_instance() {
    return {
      drive: {
        'style/': {
          'theme.css': {
            raw: `
              .graph-explorer {
                height: 300px;
                overflow: auto;
                font-family: monospace;
                color: #eee;
                background-color: #2d3440;
                user-select: none;
              }
              
              .explorer-container {
                padding: 10px;
                height: 300px;
              }
              
              .explorer-node {
                display: flex;
                align-items: center;
                padding: 2px 0;
                white-space: nowrap;
                cursor: pointer;
              }
              
              .explorer-node:hover {
                background-color: rgba(255, 255, 255, 0.1);
              }
              
              .tree-prefix {
                margin-right: 4px;
                opacity: 0.7;
                cursor: pointer;
              }
              
              .node-icon {
                margin-right: 6px;
                cursor: pointer;
              }
              
              .node-name {
                overflow: hidden;
                text-overflow: ellipsis;
              }
            `
          }
        },
        'entries/': {
          'graph.json': {
            '$ref': 'entries.json'
          }
        },
        'icons/': {
          'folder_icons.json': {
            raw: `{
              "root": "ğŸŒ",
              "folder": "ğŸ“",
              "file": "ğŸ“„",
              "html-file": "ğŸ“„",
              "js-file": "ğŸ“„",
              "css-file": "ğŸ–Œï¸",
              "json-file": "ğŸ¨"
            }`
          }
        }
      }
    }
  }
}
