const STATE = require('STATE')
const statedb = STATE(__filename)
const { sdb, get } = statedb(fallback_module)

module.exports = graph_explorer

async function graph_explorer (opts, protocol) {
  const { id, sdb } = await get(opts.sid)
  const {drive} = sdb
  const on = {
    style: inject,
    graph_data: on_graph_data,
    icons: iconject
  }

  const el = document.createElement('div')
  const shadow = el.attachShadow({ mode: 'closed' })
  shadow.innerHTML = `
  <div class="graph-explorer-container">
    <div class="graph-entries"></div>
  </div>
  <style>
  </style>`
  
  const style = shadow.querySelector('style')
  const graph_entries = shadow.querySelector('.graph-entries')

  let init = false
  let graph_data = []
  let icons = {}
  let expanded_entries = new Set()
  let super_nodes = new Map()
  let visible_super_nodes = new Set()
  
  const subs = await sdb.watch(onbatch)
  let send = null
  let _ = null
  if (protocol) {
    send = protocol(msg => onmessage(msg))
    _ = { up: send }
  }

  return el

  function create_graph_entry(entry, level = 0, parent_path = '', parent_entry = null, is_super_node = false) {
    const entry_el = document.createElement('div')
    entry_el.className = 'graph-entry'
    entry_el.style.paddingLeft = `${level * 20}px`
    
    const current_path = parent_path ? `${parent_path}/${entry.name}` : entry.name
    const super_node_path = is_super_node ? `super_${current_path}` : current_path
    const has_children = entry.children && entry.children.length > 0
    const is_expanded = expanded_entries.has(super_node_path)
    
    // Store parent relationship
    if (parent_entry) {
      super_nodes.set(current_path, parent_entry)
    }
    
    const tree_symbol = get_tree_symbol(entry, level, is_expanded, has_children, is_super_node)
    const icon = icons[entry.type] || entry.icon || 'ğŸ“'
    
    entry_el.innerHTML = `
    <span class="tree-symbol" data-path="${current_path}">${tree_symbol}</span>
    <span class="entry-icon" data-path="${current_path}">${icon}</span>
    <span class="entry-name">${entry.name}</span>
    `
    
    const tree_symbol_el = entry_el.querySelector('.tree-symbol')
    const icon_el = entry_el.querySelector('.entry-icon')
    
    // Add click event to tree symbol to show super node
    if (parent_entry && level > 0 && !is_super_node) {
      tree_symbol_el.onclick = () => toggle_super_node(current_path, parent_entry)
      tree_symbol_el.style.cursor = 'pointer'
      tree_symbol_el.title = `Show parent: ${parent_entry.name}`
    }
    
    // Add click event to icon for expanding children
    if (has_children) {
      icon_el.onclick = () => toggle_entry(super_node_path, entry)
    }
    
    return entry_el
  }

  function get_tree_symbol(entry, level, is_expanded, has_children, is_super_node = false) {
    if (level === 0) {
      return has_children ? (is_expanded ? 'ğŸª„â”¬' : 'ğŸª„â”€') : 'ğŸª„â”€'
    }
    
    const prefix = is_super_node ? 'â”Œ' : 'â”œ'
    
    if (has_children) {
      return is_expanded ? `${prefix}â”¬` : `${prefix}â”€`
    } else {
      return `${prefix}â”€`
    }
  }

  function toggle_entry(path, entry) {
    if (expanded_entries.has(path)) {
      expanded_entries.delete(path)
    } else {
      expanded_entries.add(path)
    }
    render_graph()
    
    if (protocol && _) {
      _.up({ 
        type: 'entry_toggled', 
        data: { path, expanded: expanded_entries.has(path), entry } 
      })
    }
  }

  function toggle_super_node(child_path, parent_entry) {
    const super_node_key = `super_${child_path}`
    
    if (visible_super_nodes.has(super_node_key)) {
      visible_super_nodes.delete(super_node_key)
    } else {
      visible_super_nodes.add(super_node_key)
    }
    
    render_graph()
    
    if (protocol && _) {
      _.up({ 
        type: 'super_node_toggled', 
        data: { child_path, parent_entry, visible: visible_super_nodes.has(super_node_key) } 
      })
    }
  }

  function render_graph() {
    graph_entries.innerHTML = ''
    super_nodes.clear() // Clear previous parent relationships
    
    graph_data.forEach(entry => {
      render_entry_with_super_nodes(entry)
    })
  }

  function render_entry_with_super_nodes(entry, level = 0, parent_path = '', parent_entry = null) {
    const current_path = parent_path ? `${parent_path}/${entry.name}` : entry.name
    const super_node_key = `super_${current_path}`
    
    // Show super node if it's visible - at the same level as current entry
    if (level > 0 && visible_super_nodes.has(super_node_key) && parent_entry) {
      const super_node_el = create_graph_entry(parent_entry, level, parent_path, null, true)
      graph_entries.appendChild(super_node_el)
      
      // Show super node children if expanded
      const super_node_expanded = expanded_entries.has(super_node_key)
      if (super_node_expanded && parent_entry.children && parent_entry.children.length > 0) {
        parent_entry.children.forEach(child => {
          // Render all children of the super node at the next level with correct parent path
          const super_parent_path = parent_path ? `${parent_path}/${parent_entry.name}` : parent_entry.name
          render_entry_with_super_nodes(child, level + 1, super_parent_path, parent_entry)
        })
      }
    }
    
    // Create and append the main entry
    const entry_el = create_graph_entry(entry, level, parent_path, parent_entry)
    graph_entries.appendChild(entry_el)
    
    // Recursively render children if expanded
    const has_children = entry.children && entry.children.length > 0
    const is_expanded = expanded_entries.has(current_path)
    
    if (is_expanded && has_children) {
      entry.children.forEach(child => {
        render_entry_with_super_nodes(child, level + 1, current_path, entry)
      })
    }
  }

  function onmessage ({ type, data }) {
    if (type === 'expand_entry') {
      expanded_entries.add(data.path)
      render_graph()
    } else if (type === 'collapse_entry') {
      expanded_entries.delete(data.path)
      render_graph()
    } else if (type === 'show_super_node') {
      visible_super_nodes.add(`super_${data.path}`)
      render_graph()
    } else if (type === 'hide_super_node') {
      visible_super_nodes.delete(`super_${data.path}`)
      render_graph()
    }
  }

  async function onbatch(batch) {
    for (const { type, paths } of batch){
      const data = await Promise.all(paths.map(path => drive.get(path).then(file => file.raw)))
      const func = on[type] || fail
      func(data, type)
    }
    if (!init && graph_data.length > 0) {
      render_graph()
      init = true
    }
  }

  function fail(data, type) { 
    throw new Error('invalid message', { cause: { data, type } }) 
  }

  function inject(data) {
    style.innerHTML = data.join('\n')
  }

  function on_graph_data(data) {
    graph_data = JSON.parse(data[0])
  }

  function iconject(data) {
    icons = {
      root: data[0] || 'ğŸŒ',
      folder: data[1] || 'ğŸ“',
      code: data[2] || 'ğŸ“š',
      data: data[3] || 'ğŸ“',
      tasks: data[4] || 'ğŸ—„ï¸'
    }
  }
}

function fallback_module () {
  return {
    api: fallback_instance
  }

  function fallback_instance () {
    return {
      drive: {
        'style/': {
          'theme.css': {
            raw: `
              .graph-explorer-container {
                background-color: #0d1117;
                color: #c9d1d9;
                font-family: 'Courier New', monospace;
                font-size: 14px;
                line-height: 1.4;
                padding: 12px;
                border-radius: 6px;
                border: 1px solid #21262d;
                min-height: 200px;
                max-height: 400px;
                overflow-y: auto;
              }
              .graph-entries {
                display: flex;
                flex-direction: column;
                gap: 2px;
              }
              .graph-entry {
                display: flex;
                align-items: center;
                gap: 4px;
                padding: 2px 0;
                white-space: nowrap;
                user-select: none;
              }
              .tree-symbol {
                color: #7c3aed;
                font-weight: bold;
                min-width: 24px;
              }
              .entry-icon {
                cursor: pointer;
                font-size: 16px;
                transition: transform 0.1s ease;
                min-width: 20px;
              }
              .entry-icon:hover {
                transform: scale(1.1);
              }
              .entry-name {
                color: #f0f6fc;
                font-weight: 500;
              }
              .graph-explorer-container::-webkit-scrollbar {
                width: 6px;
              }
              .graph-explorer-container::-webkit-scrollbar-track {
                background: #161b22;
                border-radius: 3px;
              }
              .graph-explorer-container::-webkit-scrollbar-thumb {
                background: #30363d;
                border-radius: 3px;
              }
              .graph-explorer-container::-webkit-scrollbar-thumb:hover {
                background: #484f58;
              }
            `
          }
        },
        'graph_data/': {
          'structure.json': {
            raw: JSON.stringify([
              {
                name: '/',
                type: 'root',
                icon: 'ğŸŒ',
                children: [
                  {
                    name: 'pins/',
                    type: 'folder',
                    icon: 'ğŸ“',
                    children: []
                  },
                  {
                    name: 'code/',
                    type: 'code',
                    icon: 'ğŸ“š',
                    children: [
                      {
                        name: 'playproject_website',
                        type: 'folder',
                        icon: 'ğŸ“–',
                        children: [
                          {
                            name: 'index.html',
                            type: 'file',
                            icon: 'ğŸ“„',
                            children: []
                          },
                          {
                            name: 'main.js',
                            type: 'file',
                            icon: 'ğŸ“„',
                            children: []
                          }
                        ]
                      },
                      {
                        name: 'theme_widget',
                        type: 'folder',
                        icon: 'ğŸ“–',
                        children: [
                          {
                            name: 'widget.html',
                            type: 'file',
                            icon: 'ğŸ“„',
                            children: []
                          },
                          {
                            name: 'widget.js',
                            type: 'file',
                            icon: 'ğŸ“„',
                            children: []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    name: 'data/',
                    type: 'data',
                    icon: 'ğŸ“',
                    children: [
                      {
                        name: 'themes/',
                        type: 'folder',
                        icon: 'ğŸ“',
                        children: [
                          {
                            name: 'fantasy.json',
                            type: 'file',
                            icon: 'ğŸ¨',
                            children: []
                          },
                          {
                            name: 'night.json',
                            type: 'file',
                            icon: 'ğŸ¨',
                            children: []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    name: 'tasks/',
                    type: 'tasks',
                    icon: 'ğŸ—„ï¸',
                    children: []
                  }
                ]
              }
            ])
          }
        },
        'icons/': {
          'root.txt': {
            raw: 'ğŸŒ'
          },
          'folder.txt': {
            raw: 'ğŸ“'
          },
          'code.txt': {
            raw: 'ğŸ“š'
          },
          'data.txt': {
            raw: 'ğŸ“'
          },
          'tasks.txt': {
            raw: 'ğŸ—„ï¸'
          }
        }
      }
    }
  }
}
